{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PlexPipe - Multiplexed Image Analysis Pipeline","text":"<p>Welcome to the documentation for the PlexPipe Image Analysis Pipeline. Use the navigation to explore tutorials, API documentation, and configuration details.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the reference documentation for all modules in the pipeline.</p>"},{"location":"api/#plex_pipe.core_cutting.cutter.CoreCutter","title":"<code>CoreCutter(margin=0, mask_value=0)</code>","text":"<p>Extract rectangular or polygonal regions from images.</p> <p>Create a new cutter.</p> <p>Parameters:</p> Name Type Description Default <code>margin</code> <code>int</code> <p>Padding to apply around each core.</p> <code>0</code> <code>mask_value</code> <code>int</code> <p>Value used outside polygon masks.</p> <code>0</code>"},{"location":"api/#plex_pipe.core_cutting.cutter.CoreCutter.extract_core","title":"<code>extract_core(array, row)</code>","text":"<p>Extract a single core from the given image.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray | Array</code> <p>Source image.</p> required <code>row</code> <code>Series</code> <p>Metadata describing the core. Required fields include <code>row_start</code>, <code>row_stop</code>, <code>column_start</code>, <code>column_stop</code> and <code>poly_type</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The extracted core image.</p>"},{"location":"what_is_plexpipe/","title":"Analysis Steps","text":"<p>PlexPipe processes multiplexed images through a series of modular steps, transforming raw whole-slide images into quantitative single-cell data.</p>"},{"location":"what_is_plexpipe/#1-core-detection","title":"1. Core Detection","text":"<p>Goal: Identify and define the boundaries of tissue cores within a whole-slide image.</p> <p>This step uses the Segment Anything Model 2 (SAM2) to automatically detect tissue cores on a specified detection image (e.g., DAPI). The pipeline analyzes the image pyramid to find regions of interest, filtering them based on area, intensity, and stability scores.</p> <ul> <li>Input: A representative whole-slide image (usually DAPI).</li> <li>Output: A list of core coordinates and masks.</li> </ul>"},{"location":"what_is_plexpipe/#2-core-cutting","title":"2. Core Cutting","text":"<p>Goal: Extract individual cores into manageable, independent datasets.</p> <p>Once cores are defined, the pipeline extracts these regions from the original OME-TIFF files. This step handles complex channel selection logic, allowing you to merge markers from different imaging rounds, exclude specific channels, or select the best version of a repeated marker.</p> <ul> <li>Input: Raw OME-TIFF images and core coordinates.</li> <li>Output: Individual SpatialData (Zarr) objects for each core.</li> </ul>"},{"location":"what_is_plexpipe/#3-image-processing","title":"3. Image Processing","text":"<p>Goal: Enhance images and segment biological objects.</p> <p>This is a highly flexible stage defined by a list of processors in the configuration. It supports:</p> <ul> <li>Image Filtering: Operations like normalization, denoising, and computing means.</li> <li>Object Segmentation: Using deep learning models (e.g., Cellpose, InstanSeg) to identify nuclei and cells.</li> <li> <p>Mask Building: Creating derivative masks, such as cytoplasmic rings or combining existing masks via boolean operations.</p> </li> <li> <p>Input: Core SpatialData objects.</p> </li> <li>Output: Processed image layers and segmentation labels stored within the SpatialData object.</li> </ul>"},{"location":"what_is_plexpipe/#4-quality-control-qc","title":"4. Quality Control (QC)","text":"<p>Goal: Exclude artifacts and ensure data quality.</p> <p>The pipeline integrates manual QC by recognizing exclusion shapes drawn by users (e.g., in Napari). Regions marked with specific prefixes (e.g., <code>qc_exclude</code>) are used to mask out cells or areas that should not be quantified, such as folded tissue or debris.</p> <ul> <li>Input: User-defined exclusion shapes.</li> <li>Output: Masked regions to be ignored during quantification.</li> </ul>"},{"location":"what_is_plexpipe/#5-quantification","title":"5. Quantification","text":"<p>Goal: Generate single-cell quantitative data.</p> <p>The final step extracts features from the segmented objects. It calculates: *   Morphological Properties: Area, centroid, eccentricity, etc. *   Intensity Properties: Mean, median, min, max expression levels for specified markers.</p> <p>The results are stored as AnnData tables within the SpatialData object, linking spatial locations to quantitative profiles for downstream analysis.</p> <ul> <li>Input: Segmentation masks and intensity images.</li> <li>Output: AnnData tables containing single-cell feature matrices.</li> </ul>"},{"location":"configuration/channel-selection/","title":"\ud83c\udfaf Channel Selection Logic","text":""},{"location":"configuration/channel-selection/#terminology","title":"Terminology","text":"<p>To understand how channels are selected, it is important to distinguish between:</p> <ul> <li>Marker Name: The biological target being imaged (e.g., <code>DAPI</code>, <code>CD44</code>, <code>pRB</code>). This is derived from the filename.</li> <li>Channel Name: The unique identifier for a specific image acquisition, combining the round number and the marker name (e.g., <code>001_DAPI</code>, <code>002_CD44</code>). This format (<code>{round:03d}_{marker}</code>) allows the pipeline to distinguish between the same marker imaged in different rounds.</li> </ul> <p>The pipeline supports fine-grained control over which imaging channels are included in processing. This is essential because:</p> <ul> <li>The same marker may be imaged multiple times across rounds (e.g., re-staining or optimization).</li> <li>DAPI is typically acquired in every round for registration but usually only one version should be kept for the analysis.</li> </ul> <p>The selection process follows this logic:</p>"},{"location":"configuration/channel-selection/#1-default-behavior-if-no-overrides","title":"1. Default Behavior (if no overrides)","text":"<ul> <li>For each marker imaged in multiple rounds, the latest round is used by default.</li> <li>For DAPI, only <code>001_DAPI</code> is included unless specified otherwise.</li> </ul>"},{"location":"configuration/channel-selection/#2-using-include_channels","title":"2. Using <code>include_channels</code>","text":"<ul> <li>This is a list of channel names like <code>002_CD44</code>, <code>001_DAPI</code>.</li> <li>If set, only these channels are included for a given marker \u2014 they override automatic selection.</li> <li>Use this to force inclusion of earlier rounds or include duplicates for comparison.</li> </ul>"},{"location":"configuration/channel-selection/#3-using-exclude_channels","title":"3. Using <code>exclude_channels</code>","text":"<ul> <li>This is a list of channel names to skip.</li> <li>If <code>include_channels</code> is not set, <code>exclude_channels</code> can be used to remove undesired versions.</li> <li>Example: to exclude <code>003_pRB</code> in favor of earlier versions (or none).</li> </ul>"},{"location":"configuration/channel-selection/#4-using-use_markers","title":"4. Using <code>use_markers</code>","text":"<ul> <li>This is a list of base marker names (like <code>DAPI</code>, <code>pRB</code>, <code>CD44</code>) after stripping the round prefix.</li> <li>After all other filtering, <code>use_markers</code> is applied as a final filter.</li> <li>Use it to narrow the final channel set to specific markers, regardless of which round was selected.</li> </ul>"},{"location":"configuration/channel-selection/#5-using-ignore_markers","title":"5. Using <code>ignore_markers</code>","text":"<ul> <li>This is a list of base marker names to exclude from the final set.</li> <li>It is applied after <code>use_markers</code>.</li> <li>Use it to discard specific markers entirely (e.g. if a marker failed quality control across all rounds).</li> </ul>"},{"location":"configuration/channel-selection/#examples","title":"Examples","text":""},{"location":"configuration/channel-selection/#example-1-default-automatic-selection","title":"Example 1: Default automatic selection","text":"<pre><code>include_channels: []\nexclude_channels: []\nuse_markers: []\n</code></pre> <ul> <li>Keeps only the latest round per marker, and <code>001_DAPI</code>.</li> </ul>"},{"location":"configuration/channel-selection/#example-2-force-earlier-prb-round-to-be-used","title":"Example 2: Force earlier pRB round to be used","text":"<pre><code>include_channels: [\"001_pRB\"]\nuse_markers: []\n</code></pre> <ul> <li><code>001_pRB</code> is used even if <code>003_pRB</code> exists.</li> </ul>"},{"location":"configuration/channel-selection/#example-3-exclude-a-problematic-round","title":"Example 3: Exclude a problematic round","text":"<pre><code>exclude_channels: [\"003_CD44\"]\n</code></pre> <ul> <li>Automatically selects an earlier round (if available) for CD44.</li> </ul>"},{"location":"configuration/channel-selection/#example-4-only-process-dapi-and-cd44","title":"Example 4: Only process DAPI and CD44","text":"<pre><code>use_markers: [\"DAPI\", \"CD44\"]\n</code></pre> <ul> <li>Filters final output to only include these two base markers.</li> </ul>"},{"location":"configuration/channel-selection/#conflicts-and-priority","title":"Conflicts and Priority","text":"<ul> <li>If a channel is listed in both <code>include_channels</code> and <code>exclude_channels</code>, a <code>ValueError</code> is raised.</li> <li><code>use_channels</code> is applied last, on the base names after channel selection.</li> </ul>"},{"location":"configuration/config_overview/","title":"\ud83d\udd27 Configuration","text":"<p>The configuration file serves as the central blueprint for the PlexPipe analysis. It provides parameters for all stages of the pipeline divided into sections corresponding to the analysis steps.</p> <p>This configuration is defined in a YAML file; you can find a deep dive into the syntax at YAML official website, but the description and examples below should be more than enough to get you started.</p>"},{"location":"configuration/config_overview/#config-validation","title":"Config Validation","text":"<p>To ensure your configuration is valid, the system validates your input against a predefined schema.</p> <p>Validation Rules:</p> <ul> <li> <p>Required Fields: These must be present in your configuration file. If a required field is missing, the application will return an error.</p> </li> <li> <p>Optional Fields: These are labeled as (optional). You can choose to:</p> <ul> <li>Omit them entirely (the system will use its default behavior).</li> <li>Set them to null (or ~) to explicitly signify no custom value.</li> <li>Provide a custom value to override the default.</li> </ul> </li> </ul>"},{"location":"configuration/config_overview/#path-format","title":"Path Format","text":"<p>When entering file paths in this configuration file, always use the forward slash (/) as the folder separator, even on Windows. The backslash (\\) is a \"special character\" in YAML. Using it can cause errors or require you to \"double-up\" your slashes (e.g., C:\\\\Users).</p> <p>Correct: C:/path/to/images Avoid: C:\\path\\to\\images.</p>"},{"location":"configuration/config_overview/#examples","title":"Examples","text":"<p>Full example configuration files can be found in the examples folder.</p> <p>The following sections detail the configuration parameters for each step of the pipeline.</p>"},{"location":"configuration/config_overview/#general-settings","title":"General Settings","text":"<p>This section defines the fundamental paths and naming conventions for the analysis run, including the source image directory and the output location.</p> <pre><code># -----------------------------------------------------------------------------\n# 1. General Settings\n# -----------------------------------------------------------------------------\ngeneral:\n  image_dir: C:/path/to/images\n  analysis_name: experiment_01\n  analysis_root_dir: C:/analysis_out\n  log_dir: null\n</code></pre> Key Type Description <code>image_dir</code> <code>Path</code> Source directory with tiff images. For differences between the local and Globus use see Input Data. <code>analysis_name</code> <code>str</code> Name of the analysis run. <code>analysis_root_dir</code> <code>Path</code> Analysis output base directory. Analysis will be saved in <code>analysis_toot_dir/analysis_name</code> referred to as <code>analysis_dir</code>. <code>log_dir</code> <code>Path</code> (optional) Custom log directory. Defaults to <code>analysis_dir/logs</code>."},{"location":"configuration/config_overview/#core-detection","title":"Core Detection","text":"<p>This section configures the automatic detection of tissue cores. It specifies the image used for detection and the parameters for the Segment Anything Model (SAM2) to accurately identify core boundaries.</p> <pre><code>######################################################\n# core detection\n######################################################\ncore_detection:\n  detection_image: \"BLCA-1_1.0.4_R000_DAPI__FINAL_F.ome.tif\"\n  core_info_file_path: null\n\n  sam:\n    im_level: 6\n    min_area: 2000\n    max_area: 20000\n    min_iou: 0.8\n    min_st: 0.9\n    min_int: 15\n    frame: 4\n</code></pre> Key Type Description <code>detection_image</code> <code>str</code> Required. Name of the image in <code>image_dir</code> used for defining cores. <code>core_info_file_path</code> <code>Path (optional)</code> Custom path for core coordinates. Defaults to <code>analysis_dir/cores.csv</code>. sam Group (optional) SAM2 Configuration. If this key is present, all sub-fields below must be specified. <code>sam.im_level</code> <code>int</code> Pyramid level to read from the image for core definition. <code>sam.min_area</code> <code>int</code> Minimum pixel area for a detected core to be considered valid. <code>sam.max_area</code> <code>int</code> Maximum pixel area for a detected core to be considered valid. <code>sam.min_iou</code> <code>float</code> SAM2 intersection-over-union threshold for mask quality. <code>sam.min_st</code> <code>float</code> SAM2 stability score threshold. <code>sam.min_int</code> <code>int</code> SAM2 intensity threshold for mask filtering. <code>sam.frame</code> <code>int</code> Number of pixels to add as padding to the core bounding box. <p>For detailed examples of how to configure SAM2 using various parameter settings, please refer to the official SAM2 repository.</p>"},{"location":"configuration/config_overview/#core-cutting","title":"Core Cutting","text":"<p>This section controls the extraction of individual cores from the original whole-slide images. It allows for precise channel selection, definition of output directories, and configuration of core processing parameters such as margins and masking.</p> <pre><code>######################################################\n# core cutting\n######################################################\ncore_cutting:\n  cores_dir_tif: null # =&gt; ${analysis_dir}/cores\n  cores_dir_output: null # =&gt; ${analysis_dir}/temp\n\n  include_channels:\n  exclude_channels:\n    - 008_ECad\n  use_markers:\n  ignore_markers:\n    - Antibody1\n  margin: 0\n  mask_value: 0\n  transfer_cleanup_enabled: True\n  core_cleanup_enabled: True\n</code></pre> Key Type Description <code>cores_dir_tif</code> <code>Path</code> (optional) Temporary folder to store extracted TIFFs for each core. Defaults to <code>analysis_dir/temp</code>. <code>cores_dir_output</code> <code>Path</code> (optional) Final destination for SpatialData (Zarr) outputs. Defaults to <code>analysis_dir/cores</code>. <code>include_channels</code> <code>list[str]</code> (optional) List of channel names to include. <code>exclude_channels</code> <code>list[str]</code> (optional) List of channel names to exclude. <code>use_markers</code> <code>list[str]</code> (optional) List to restrict markers to analyze. <code>ignore_markers</code> <code>list[str]</code> (optional) List to ignore markers. <code>margin</code> <code>int</code> (optional) Number of pixels to pad around each bounding box when cutting cores. Defaults to 0. <code>mask_value</code> <code>int</code> (optional) Value used to fill background for polygonal core masks. Defaults to 0. <code>transfer_cleanup_enabled</code> <code>bool</code> (optional) Whether to delete temporary files downloaded via Globus after the run. Defaults to False. <code>core_cleanup_enabled</code> <code>bool</code> (optional) Whether to delete TIFFs from <code>cores_dir_tif</code> after core assembly. Defaults to False. For details see Input Data. <p>Parameters <code>include_channels</code>, <code>exclude_channels</code>, <code>use_markers</code> and <code>ignore_markers</code> provide a fine-grained control over which imaging channels are included in processing. See Channel Selection Logic for details.</p>"},{"location":"configuration/config_overview/#image-processing","title":"Image Processing","text":"<pre><code># -----------------------------------------------------------------------------\n# 4. Image Processing (Filtering, Segmentation, Buiding Derivative Masks etc.)\n# -----------------------------------------------------------------------------\nadditional_elements:\n\n  - category: image_filter\n    type: normalize\n    input: [DAPI, HLA1]\n    output: \"${input}_norm\"\n    parameters:\n      low: 1\n      high: 99.8\n    keep: false\n\n  - category: object_segmenter\n    type: instanseg\n    parameters:\n      model: fluorescence_nuclei_and_cells\n      pixel_size: 0.3\n      resolve_cell_and_nucleus: true\n      cleanup_fragments: true\n      clean_cache: true\n      normalise: false\n    input:\n      - DAPI_norm\n      - HLA1_norm\n    output:\n      - instanseg_nucleus\n      - instanseg_cell\n    keep: true\n\n  - category: mask_builder\n    type: ring\n    input:\n        - instanseg_nucleus\n    output: ring\n    parameters:\n      outer: 8\n      inner: 2\n    keep: true\n</code></pre> <p>The pipeline allows for flexible image processing steps defined in the Processors list. Each entry in this list is a processing unit that takes inputs (images or labels), performs an operation, and produces outputs.</p>"},{"location":"configuration/config_overview/#structure-of-an-element","title":"Structure of an Element","text":"Key Type Description <code>category</code> <code>str</code> The category of the operation. Options: <code>image_filter</code>, <code>object_segmenter</code>, <code>mask_builder</code>. <code>type</code> <code>str</code> The specific operation name (e.g., <code>normalize</code>, <code>instanseg</code>). <code>input</code> <code>str</code> | <code>list</code> The name(s) of input images or channels. <code>output</code> <code>str</code> | <code>list</code> The name(s) assigned to the results. Supports variable expansion like <code>${input}_norm</code>. <code>parameters</code> <code>dict</code> (optional) Specific parameters for the operation. <code>keep</code> <code>bool</code> (optional) Whether to save the output to the final Zarr file (<code>true</code>) or keep it temporary (<code>false</code>). Defaults to <code>false</code>. <p>For a complete list of available operations and their parameters, see Processors.</p>"},{"location":"configuration/config_overview/#quality-control","title":"Quality Control","text":"<p>This section manages quality control parameters, specifically defining prefixes for exclusion masks. These masks are used to filter out artifacts or unwanted regions from downstream analysis.</p> <pre><code>######################################################\n# qc\n######################################################\nqc:\n  prefix: qc_exclude\n</code></pre> Key Type Description <code>prefix</code> <code>str</code> (optional) Prefix for shapes used for quality control exclusion. Shapes named <code>{prefix}_{marker}</code> will be used to mask out objects for specific markers."},{"location":"configuration/config_overview/#quantification","title":"Quantification","text":"<p>The <code>quant</code> section allows you to define one or more quantification tasks.  Each entry in the list corresponds to a separate AnnData table that will be generated and stored in the SpatialData object.  This is useful if you have multiple segmentation results (e.g., cells and nuclei, or different cell segmentation models) and want to quantify them independently. Example below specifies only a single AnnData table to be created ('instanseg_table').</p> <pre><code>######################################################\n# quantification\n######################################################\nquant:\n  - name: instanseg_table\n    masks: \n      nucleus: instanseg_nucleus\n      cell: instanseg_cell\n      ring: ring\n      cyto: cytoplasm\n    layer_connection: instanseg_cell\n    morphological_properties:\n      - label\n      - centroid\n      - area\n    intensity_properties:\n      - median\n    markers_to_quantify:\n      - DAPI\n      - HLA1\n    add_qc_masks: True\n</code></pre> Key Type Description <code>name</code> <code>str</code> Name of the output AnnData table to be saved in the SpatialData object. <code>masks</code> <code>dict[str, str]</code> Dictionary mapping suffixes (e.g., nucleus, cell) to the actual mask layer names in the SpatialData object. <code>layer_connection</code> <code>str</code> (optional) The mask layer name to which the table should be linked (e.g. for visualization in Napari Spatialdata plugin). <code>morphological_properties</code> <code>list[str]</code> (optional) List of morphological features to calculate. 'Label' is added automatically if absent from the custom list to identify objects. Defaults to [\"label\", \"centroid\", \"area\", \"eccentricity\", \"solidity\", \"perimeter\", \"euler_number\"]. <code>intensity_properties</code> <code>list[str]</code> (optional) List of intensity metrics to calculate. Defaults to ['mean', 'median']. <code>markers_to_quantify</code> <code>list[str]</code> (optional) List of specific markers to quantify itensity properties. If omitted, all available channels are quantified. <code>add_qc_masks</code> <code>bool</code> (optional) If True, uses polygons defined in the QC step to create a mask layer in the AnnData table indicating which objects are from the accepted regions. Defaults to False. <p>For <code>morphological_properties</code>, any property supported by skimage.measure.regionprops can be used.</p> <p>For <code>intensity_properties</code>, currently implemented metrics include <code>mean</code>, <code>median</code> <code>min</code>, <code>max</code>, <code>std</code> and <code>sum</code>. If you require other metrics, please open an issue on GitHub.</p>"},{"location":"configuration/config_overview/#storage-settings","title":"Storage Settings","text":"<p>This section defines the storage parameters for the resulting SpatialData objects (Zarr files). It controls performance-related settings such as chunk sizes and the generation of multi-scale image pyramids.</p> <pre><code>######################################################\n# storage settings\n######################################################\nsdata_storage:\n  chunk_size: [1, 512, 512]\n  max_pyramid_level: 3\n  downscale: 2\n</code></pre> Key Type Description chunk_size list[int] (optional) Dimensions of the data chunks stored in the Zarr array Defaults to [1, 512, 512]. max_pyramid_level int (optional) Number of multiscale pyramid levels to generate. Defaults to 4. downscale int (optional) Downsampling factor applied between consecutive pyramid levels. Defaults to 2."},{"location":"configuration/processors/","title":"Available Processors","text":""},{"location":"configuration/processors/#image-filter","title":"Image Filter","text":""},{"location":"configuration/processors/#denoise_with_median","title":"<code>denoise_with_median</code>","text":"<p>Applies a median filter to the image to remove noise.</p> <ul> <li>Inputs: 1</li> <li>Outputs: 1</li> <li>Parameters:<ul> <li><code>disk_radius</code> (, default=<code>3</code>): The radius of the disk-shaped kernel for the median filter."},{"location":"configuration/processors/#mean_of_images","title":"<code>mean_of_images</code>","text":"<p>Compute the mean of multiple image arrays.</p> <ul> <li>Inputs: Variable</li> <li>Outputs: 1</li> <li>Parameters: None.</li> </ul>"},{"location":"configuration/processors/#normalize","title":"<code>normalize</code>","text":"<p>Performs percentile-based normalization on the image.</p> <ul> <li>Inputs: 1</li> <li>Outputs: 1</li> <li>Parameters:<ul> <li><code>low</code> (, default=<code>1.0</code>): Lower percentile bound (0-100). <li><code>high</code> (, default=<code>99.0</code>): Upper percentile bound (0-100)."},{"location":"configuration/processors/#mask-builder","title":"Mask Builder","text":""},{"location":"configuration/processors/#blob","title":"<code>blob</code>","text":"<p>Processes a mask to create blob-like shapes using morphological operations.</p> <ul> <li>Inputs: 1</li> <li>Outputs: 1</li> <li>Parameters:<ul> <li><code>work_shape</code> (Tuple[int, int], default=<code>(250, 250)</code>): No description.</li> <li><code>radius</code> (, default=<code>5</code>): No description."},{"location":"configuration/processors/#multiply","title":"<code>multiply</code>","text":"<p>Multiplies two masks (intersection).</p> <ul> <li>Inputs: 2</li> <li>Outputs: 1</li> <li>Parameters: None.</li> </ul>"},{"location":"configuration/processors/#ring","title":"<code>ring</code>","text":"<p>Creates a ring-shaped mask around objects.</p> <ul> <li>Inputs: 1</li> <li>Outputs: 1</li> <li>Parameters:<ul> <li><code>outer</code> (, default=<code>7</code>): The outer radius of the ring in pixels. <li><code>inner</code> (, default=<code>2</code>): The inner radius of the ring in pixels."},{"location":"configuration/processors/#subtract","title":"<code>subtract</code>","text":"<p>Subtracts one mask from another (mask1 - mask2).</p> <ul> <li>Inputs: 2</li> <li>Outputs: 1</li> <li>Parameters: None.</li> </ul>"},{"location":"configuration/processors/#object-segmenter","title":"Object Segmenter","text":""},{"location":"configuration/processors/#cellpose","title":"<code>cellpose</code>","text":"<p>Uses the Cellpose deep learning model for segmentation.</p> <ul> <li>Inputs: Variable</li> <li>Outputs: 1</li> <li>Parameters:<ul> <li><code>diameter</code> (Optional[float], default=<code>30</code>): From Cellpose documentation: Scaling factor for the segmentation. Default size of cells 30 - segments well objects of size 10 -120.</li> <li><code>flow_threshold</code> (Optional[float], default=<code>0.4</code>): From Cellpose documentation: Maximum allowed flow error per mask (flow_threshold, default = 0.4). Increase it if too few ROIs are detected; decrease it if too many poor-quality ROIs appear.</li> <li><code>cellprob_threshold</code> (Optional[float], default=<code>0</code>): From Cellpose documentation: Pixel threshold to define ROIs. Lower the threshold if too few ROIs are detected; raise it if too many\u2014especially from dim regions.</li> <li><code>niter</code> (Optional[int], default=<code>0</code>): From Cellpose documentation: If niter is None or 0, it scales with ROI size\u2014use larger values (e.g., niter=2000) for longer ROIs.</li> </ul> </li> </ul>"},{"location":"configuration/processors/#instanseg","title":"<code>instanseg</code>","text":"<p>Uses the InstanSeg deep learning model for segmentation.</p> <ul> <li>Inputs: Variable</li> <li>Outputs: Variable</li> <li>Parameters:<ul> <li><code>model</code> (Literal['fluorescence_nuclei_and_cells', 'brightfield_nuclei'], default=<code>fluorescence_nuclei_and_cells</code>): No description.</li> <li><code>pixel_size</code> (, default=<code>0.3</code>): Scaling factor for the segmentation. <li><code>resolve_cell_and_nucleus</code> (, default=<code>True</code>): No description. <li><code>cleanup_fragments</code> (, default=<code>True</code>): No description. <li><code>clean_cache</code> (, default=<code>False</code>): No description. <li><code>normalise</code> (, default=<code>True</code>): No description. <li><code>overlap</code> (, default=<code>80</code>): No description."},{"location":"usage/execution_modes/","title":"Usage","text":"<p>PlexPipe supports command-line execution and interactive analysis via Jupyter notebooks. For scalable workflows, it can also be orchestrated through Nextflow (see plex-pipe-nextflow).</p>"},{"location":"usage/execution_modes/#command-line-usage","title":"Command-Line Usage","text":"<p>To run the pipeline from the command line, use the provided scripts:</p>"},{"location":"usage/execution_modes/#prepare-cores","title":"Prepare Cores","text":"<pre><code>python scripts/prepare_cores.py --config config/analysis_pipeline.yaml\n</code></pre> <p>This script wraps the <code>CoreController</code> class, which handles:</p> <ul> <li>Reading image and metadata files.</li> <li>Cutting out cores with appropriate margins and masking.</li> <li>Writing intermediate TIFFs.</li> <li>Assembling per-core Zarr datasets using the SpatialData model.</li> </ul> <p>For more details, see the <code>core_cutter.py</code> source and its configuration.</p>"},{"location":"usage/execution_modes/#jupyter-notebook-usage","title":"Jupyter Notebook Usage","text":"<p>For interactive inspection, prototyping, or educational purposes, the following notebooks illustrate how to use the components directly:</p> <ul> <li><code>core_selection_demo.ipynb</code>: An interactive notebook that enables users to define cores as rectangles or polygons using the Napari viewer. It supports automatic core detection via Segment Anything v2, with the option to manually correct the detected shapes or draw new ones from scratch. This step is interactive and only available as a notebook. The result is a <code>core_info.csv</code> file containing core metadata for use in subsequent steps via either Jupyter or CLI.</li> <li><code>core_cutting_demo.ipynb</code>: Demonstrates how to load a single image and metadata entry and apply the core cutting logic.</li> </ul>"},{"location":"usage/input_data/","title":"Input Data","text":""},{"location":"usage/input_data/#file-naming-convention","title":"File Naming Convention","text":"<p>The pipeline expects OME-TIFF files to follow a specific naming convention (typical of processed CellDive data). The filename is parsed to extract the round number and marker name.</p> <p>Format: <code>[Prefix]_[Round].0.4_R000_[Dye]_[Marker]-[Suffix].ome.tif</code></p> <ul> <li>Round: Extracted from the second segment (e.g., <code>001</code> from <code>..._1.0.4_...</code>).</li> <li>Marker:<ul> <li>If the <code>[Dye]</code> segment contains \"DAPI\", the marker is set to <code>DAPI</code>.</li> <li>Otherwise, the marker is extracted from the <code>[Marker]</code> segment (everything before the first hyphen <code>-</code>).</li> </ul> </li> </ul> <p>Example:</p> <ul> <li>File: <code>BLCA-1_1.0.4_R000_Cy3_pH2AX-AF555_FINAL_AFR_F.ome.tif</code></li> <li>Round: 1</li> <li>Marker: pH2AX</li> <li>Channel Name: <code>001_pH2AX</code></li> </ul>"},{"location":"usage/input_data/#sourcing-image-files","title":"Sourcing Image Files","text":"<p>Original tiff files are required to divide into separate SpatialData objects in the Core Cutting step.</p> <p>Core cutting supports two modes of operation:</p> <ul> <li>Local mode: Tiff files are available on the local filesystem.</li> <li>Globus mode: Tiff files are accessed remotely using Globus endpoints.</li> </ul> <p>Differences in local vs. Globus mode come from how OME-TIFF files are sourced.</p>"},{"location":"usage/input_data/#local-mode","title":"\ud83d\udcf0 Local Mode","text":"<p>In local mode, <code>image_dir</code> should point to a folder with accessible OME-TIFF files on disk.</p> <pre><code>image_dir: \"C:/path_to_image_directory\"\n</code></pre>"},{"location":"usage/input_data/#globus-mode","title":"\u2601\ufe0f Globus Mode","text":"<p>In Globus mode, you must also specify the path to a Globus configuration directory. The <code>image_dir</code> field should reflect the remote directory on the Globus endpoint:</p> <pre><code>image_dir: \"/my_globus/path_to_image_directory\"\n</code></pre> <p>This allows the pipeline to discover and transfer files on demand via Globus.</p> <p>Work in progress explain Globus settings file.</p>"},{"location":"usage/processors/","title":"Available Processors","text":""},{"location":"usage/processors/#image-filter","title":"Image Filter","text":""},{"location":"usage/processors/#denoise_with_median","title":"<code>denoise_with_median</code>","text":"<p>Applies a median filter to the image to remove noise.</p> <ul> <li>Inputs: 1</li> <li>Outputs: 1</li> <li>Parameters:<ul> <li><code>disk_radius</code> (, default=<code>3</code>): The radius of the disk-shaped kernel for the median filter."},{"location":"usage/processors/#mean_of_images","title":"<code>mean_of_images</code>","text":"<p>Compute the mean of multiple image arrays.</p> <ul> <li>Inputs: Variable</li> <li>Outputs: 1</li> <li>Parameters: None.</li> </ul>"},{"location":"usage/processors/#normalize","title":"<code>normalize</code>","text":"<p>Performs percentile-based normalization on the image.</p> <ul> <li>Inputs: 1</li> <li>Outputs: 1</li> <li>Parameters:<ul> <li><code>low</code> (, default=<code>1.0</code>): Lower percentile bound (0-100). <li><code>high</code> (, default=<code>99.0</code>): Upper percentile bound (0-100)."},{"location":"usage/processors/#mask-builder","title":"Mask Builder","text":""},{"location":"usage/processors/#blob","title":"<code>blob</code>","text":"<p>Processes a mask to create blob-like shapes using morphological operations.</p> <ul> <li>Inputs: 1</li> <li>Outputs: 1</li> <li>Parameters:<ul> <li><code>work_shape</code> (Tuple[int, int], default=<code>(250, 250)</code>): No description.</li> <li><code>radius</code> (, default=<code>5</code>): No description."},{"location":"usage/processors/#multiply","title":"<code>multiply</code>","text":"<p>Multiplies two masks (intersection).</p> <ul> <li>Inputs: 2</li> <li>Outputs: 1</li> <li>Parameters: None.</li> </ul>"},{"location":"usage/processors/#ring","title":"<code>ring</code>","text":"<p>Creates a ring-shaped mask around objects.</p> <ul> <li>Inputs: 1</li> <li>Outputs: 1</li> <li>Parameters:<ul> <li><code>outer</code> (, default=<code>7</code>): The outer radius of the ring in pixels. <li><code>inner</code> (, default=<code>2</code>): The inner radius of the ring in pixels."},{"location":"usage/processors/#subtract","title":"<code>subtract</code>","text":"<p>Subtracts one mask from another (mask1 - mask2).</p> <ul> <li>Inputs: 2</li> <li>Outputs: 1</li> <li>Parameters: None.</li> </ul>"},{"location":"usage/processors/#object-segmenter","title":"Object Segmenter","text":""},{"location":"usage/processors/#cellpose","title":"<code>cellpose</code>","text":"<p>Uses the Cellpose deep learning model for segmentation.</p> <ul> <li>Inputs: Variable</li> <li>Outputs: 1</li> <li>Parameters:<ul> <li><code>diameter</code> (Optional[float], default=<code>30</code>): From Cellpose documentation: Scaling factor for the segmentation. Default size of cells 30 - segments well objects of size 10 -120.</li> <li><code>flow_threshold</code> (Optional[float], default=<code>0.4</code>): From Cellpose documentation: Maximum allowed flow error per mask (flow_threshold, default = 0.4). Increase it if too few ROIs are detected; decrease it if too many poor-quality ROIs appear.</li> <li><code>cellprob_threshold</code> (Optional[float], default=<code>0</code>): From Cellpose documentation: Pixel threshold to define ROIs. Lower the threshold if too few ROIs are detected; raise it if too many\u2014especially from dim regions.</li> <li><code>niter</code> (Optional[int], default=<code>0</code>): From Cellpose documentation: If niter is None or 0, it scales with ROI size\u2014use larger values (e.g., niter=2000) for longer ROIs.</li> </ul> </li> </ul>"},{"location":"usage/processors/#instanseg","title":"<code>instanseg</code>","text":"<p>Uses the InstanSeg deep learning model for segmentation.</p> <ul> <li>Inputs: Variable</li> <li>Outputs: Variable</li> <li>Parameters:<ul> <li><code>model</code> (Literal['fluorescence_nuclei_and_cells', 'brightfield_nuclei'], default=<code>fluorescence_nuclei_and_cells</code>): No description.</li> <li><code>pixel_size</code> (, default=<code>0.3</code>): Scaling factor for the segmentation. <li><code>resolve_cell_and_nucleus</code> (, default=<code>True</code>): No description. <li><code>cleanup_fragments</code> (, default=<code>True</code>): No description. <li><code>clean_cache</code> (, default=<code>False</code>): No description. <li><code>normalise</code> (, default=<code>True</code>): No description. <li><code>overlap</code> (, default=<code>80</code>): No description."}]}